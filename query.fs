FeatureScript 2345; /* Automatically generated version */
// This module is part of the FeatureScript Standard Library and is distributed under the MIT License.
// See the LICENSE tab for the license text.
// Copyright (c) 2013-Present PTC Inc.

/**
 * Functions for constructing queries.
 * Features that take queries as inputs should re-export this module.
 *
 * Queries are used to refer to topological entities (vertices, edges, faces,
 * and bodies) that FeatureScript operation and evaluation functions work on.
 * A query is a map that contains instructions for how to find entities. For
 * example, a query for all edges in a context looks like
 *`qEverything(EntityType.EDGE)`.
 * Many queries can take subqueries as arguments, allowing for more complex
 * nested queries.
 *
 * Queries in general do not contain a list of entities in any form. Rather,
 * they contain criteria that specify a subset of the topological entities in a
 * context. To get an array of the entities (if any) which match a query in
 * a context, use `evaluateQuery`. There is no need to evaluate a query before
 * passing it into a function, including any of the Standard Library's operation
 * and evaluation functions.
 *
 * There are two general types of queries: state-based and historical.
 * State-based queries select entities based on the model state, e.g. "All
 * edges adjacent to a cylindrical face which touches this point." Historical
 * queries select entities based on the model history, e.g. "the edge that was
 * generated by feature `extrude_1_id` from sketch vertex `vertex_id` from
 * sketch `sketch_id`." State-based queries cannot refer to entities that have
 * been deleted. Most automatically-generated queries are historical, while
 * queries more commonly used in manually written code are state-based.
 */

export import(path : "onshape/std/edgetopology.gen.fs", version : "2345.0");
import(path : "onshape/std/containers.fs", version : "2345.0");
import(path : "onshape/std/context.fs", version : "2345.0");
import(path : "onshape/std/mathUtils.fs", version : "2345.0");
import(path : "onshape/std/surfaceGeometry.fs", version : "2345.0");
import(path : "onshape/std/units.fs", version : "2345.0");
import(path : "onshape/std/curveGeometry.fs", version : "2345.0");
import(path : "onshape/std/featureList.fs", version : "2345.0");

/**
 * A `Query` identifies a specific subset of a context's entities (points, lines,
 * planes, and bodies).
 *
 * The fields on a Query map depend on its `QueryType`, and may include one or
 * more subqueries.
 *
 * @type {{
 *      @field queryType {QueryType}
 *      @field entityType {EntityType} : @optional
 * }}
 */
export type Query typecheck canBeQuery;

/** Typecheck for [Query] */
export predicate canBeQuery(value)
{
    value is map;
    value.queryType is QueryType || value.historyType is string;
    value.entityType is undefined || value.entityType is EntityType;
}

/**
 * @internal
 *
 * An enumeration describing how a query searches for matching entities.
 *
 * Queries of a given type can instead be created using their corresponding constructor.
 * For instance, the query
 * `{ "queryType" : QueryType.EVERYTHING, "entityType" : EntityType.BODY }`
 * is created with `qEverything(EntityType.BODY)`, and its behavior is
 * described on the documentation for the function `qEverything`.
 *
 ******************************************************************************
 * @value NOTHING                    : Used in [qNothing]
 * @value EVERYTHING                 : Used in [qEverything]
 * @value NTH_ELEMENT                : Used in [qNthElement]
 * @value ENTITY_FILTER              : Used in [qEntityFilter]
 * @value HISTORICAL                 : Used in historical queries
 * @value CREATED_BY                 : Used in [qCreatedBy]
 * @value SKETCH_REGION              : Used in [qSketchRegion]
 * @value UNIQUE_VERTICES            : Used in [qUniqueVertices]
 * @value TRANSIENT                  : Used in [qTransient]
 * @value OP_HOLE_PROFILE            : Used in [qOpHoleProfile]
 * @value OP_HOLE_FACE               : Used in [qOpHoleFace]
 * @value TOLERANCE_FILTER           : Used in [qToleranceFilter]
 * @value UNION                      : Used in [qUnion]
 * @value INTERSECTION               : Used in [qIntersection]
 * @value SUBTRACTION                : Used in [qSubtraction]
 * @value OWNED_BY_PART              : Used in [qOwnedByBody]
 * @value OWNER_PART                 : Used in [qOwnerBody]
 * @value CONTAINED_IN_COMPOSITE     : Used in [qContainedInCompositeParts]
 * @value COMPOSITE_CONTAINING       : Used in [qCompositePartsContaining]
 * @value VERTEX_ADJACENT            : Used in [qVertexAdjacent]
 * @value EDGE_ADJACENT              : Used in [qEdgeAdjacent]
 * @value LOOP_AROUND_FACE           : Not yet implemented
 * @value SHELL_CONTAINING_FACE      : Not yet implemented
 * @value GEOMETRY                   : Used in [qGeometry]
 * @value BODY_TYPE                  : Used in [qBodyType]
 * @value PLANE_NORMAL               : Used in [qParallelPlanes]
 * @value TANGENT_EDGES              : Not yet implemented
 * @value TANGENT_FACES              : Not yet implemented
 * @value CONVEX_CONNECTED_FACES     : Used in [qConvexConnectedFaces]
 * @value CONCAVE_CONNECTED_FACES    : Used in [qConcaveConnectedFaces]
 * @value TANGENT_CONNECTED_FACES    : Used in [qTangentConnectedFaces]
 * @value LOOP_BOUNDED_FACES         : Used in [qLoopBoundedFaces]
 * @value FACE_OR_EDGE_BOUNDED_FACES : Used in [qFaceOrEdgeBoundedFaces]
 * @value HOLE_FACES                 : Used in [qHoleFaces]
 * @value FILLET_FACES               : Used in [qFilletFaces]
 * @value PATTERN                    : Used in [qMatching]
 * @value PATTERN_INSTANCES          : Used in [qPatternInstances]
 * @value CONTAINS_POINT             : Used in [qContainsPoint]
 * @value INTERSECTS_LINE            : Used in [qIntersectsLine]
 * @value INTERSECTS_PLANE           : Used in [qIntersectsPlane]
 * @value INTERSECTS_BALL            : Used in [qWithinRadius]
 * @value CLOSEST_TO                 : Used in [qClosestTo]
 * @value FARTHEST_ALONG             : Used in [qFarthestAlong]
 * @value LARGEST                    : Used in [qLargest]
 * @value SMALLEST                   : Used in [qSmallest]
 * @value COEDGE                     : Used in [qCoEdge]
 * @value MATE_CONNECTOR             : Used in [qMateConnectorsOfParts]
 * @value CONSTRUCTION_FILTER        : Used in [qConstructionFilter]
 * @value DEPENDENCY                 : Used in [qDependency]
 * @value TRACKING                   : Used in [startTracking]
 * @value CAP_ENTITY                 : Used in [qCapEntity]
 * @value SOURCE_MESH                : Used in [qSourceMesh]
 * @value ACTIVE_SM_FILTER           : Used in [qActiveSheetMetalFilter]
 * @value CORRESPONDING_IN_FLAT      : Used in [qCorrespondingInFlat]
 * @value PARTS_ATTACHED_TO          : Used in [qPartsAttachedTo]
 * @value SM_FLAT_FILTER             : Used in [qSheetMetalFlatFilter]
 * @value SKETCH_OBJECT_FILTER       : Used in [qSketchFilter]
 * @value EDGE_TOPOLOGY_FILTER       : Used in [qEdgeTopologyFilter]
 * @value COINCIDES_WITH_PLANE       : Used in [qCoincidesWithPlane]
 * @value LAMINAR_DEPENDENCY         : Used in [qLaminarDependency]
 * @value PLANE_PARALLEL_DIRECTION   : Used in [qPlanesParallelToDirection]
 * @value FACE_PARALLEL_DIRECTION    : Used in [qFacesParallelToDirection]
 * @value TANGENT_CONNECTED_EDGES    : Used in [qTangentConnectedEdges]
 * @value LOOP_EDGES                 : Used in [qLoopEdges]
 * @value PARALLEL_EDGES             : Used in [qParallelEdges]
 * @value CONSUMED                   : Used in [qConsumed]
 * @value COMPOSITE_PART_TYPE_FITLER : Used in [qCompositePartTypeFilter]
 * @value COINCIDENT                 : Used in [qCoincidentFilter]

 ******************************************************************************/
export enum QueryType
{
    //Special
    NOTHING,
    EVERYTHING,
    NTH_ELEMENT,
    ENTITY_FILTER,
    HISTORICAL,
    CREATED_BY,
    SKETCH_REGION,
    UNIQUE_VERTICES,
    TRANSIENT,
    ATTRIBUTE_FILTER,
    PATTERN_INSTANCES,
    OP_HOLE_PROFILE,
    OP_HOLE_FACE,
    TOLERANCE_FILTER,
    //Sheet metal
    ACTIVE_SM_FILTER,
    CORRESPONDING_IN_FLAT,
    PARTS_ATTACHED_TO,
    SM_FLAT_FILTER,
    //Boolean
    UNION,
    INTERSECTION,
    SUBTRACTION,
    //Topological
    OWNED_BY_PART,
    OWNER_PART,
    CONTAINED_IN_COMPOSITE,
    COMPOSITE_CONTAINING,
    VERTEX_ADJACENT,
    EDGE_ADJACENT,
    LOOP_AROUND_FACE,
    SHELL_CONTAINING_FACE,
    EDGE_TOPOLOGY_FILTER,
    EDGE_VERTEX,
    //Geometry types
    GEOMETRY,
    BODY_TYPE,
    //Geometry matching -- TODO
    PLANE_NORMAL,
    //Tangency
    TANGENT_EDGES,
    TANGENT_FACES,
    // face related queries
    CONVEX_CONNECTED_FACES,
    CONCAVE_CONNECTED_FACES,
    TANGENT_CONNECTED_FACES,
    LOOP_BOUNDED_FACES,
    FACE_OR_EDGE_BOUNDED_FACES,
    HOLE_FACES,
    FILLET_FACES,
    PATTERN,
    // edge related queries
    TANGENT_CONNECTED_EDGES,
    LOOP_EDGES,
    PARALLEL_EDGES,
    //Containment / Intersection
    CONTAINS_POINT,
    INTERSECTS_LINE,
    INTERSECTS_PLANE,
    INTERSECTS_BALL,
    //Optimization
    CLOSEST_TO, //point
    FARTHEST_ALONG, //direction
    LARGEST,
    SMALLEST,
    COEDGE,
    MATE_CONNECTOR,
    CONSTRUCTION_FILTER,
    DEPENDENCY,
    TRACKING,
    CAP_ENTITY,
    SOURCE_MESH,
    MESH_GEOMETRY_FILTER,
    MODIFIABLE_ENTITY_FILTER,
    SKETCH_OBJECT_FILTER,
    COINCIDES_WITH_PLANE,
    LAMINAR_DEPENDENCY,
    PLANE_PARALLEL_DIRECTION,
    FACE_PARALLEL_DIRECTION,
    CONSUMED,
    COMPOSITE_PART_TYPE_FITLER,
    COINCIDENT
}

/**
 * Specifies the topological type of a body.
 *
 * All bodies have `EntityType.BODY`, but will generally own many entities of
 * other `EntityType`s.
 *
 * For example, the result of an extrude with `NewBodyOperationType.NEW` is a
 * body. This body will have `BodyType.SOLID` for a solid extrude, and
 *`BodyType.SHEET` for a surface extrude. This extrude operation will create
 * many geometric entities in the context (faces, edges, or vertices), which
 * are owned by the body, and have the `BodyType` of their owning body.
 *
 * @seealso [qBodyType]
 *
 * @value SOLID : A three-dimensional part (e.g. the result of a solid extrude)
 * @value SHEET : A two-dimensional sheet body (e.g. a sketch region, or the
 *      result of a surface extrude)
 * @value WIRE  : A one-dimensional curve (e.g. a sketch line or curve, or the
 *      result of opHelix)
 * @value POINT : A zero-dimensional point (e.g. a sketch point, or the result
 *      of opPoint)
 * @value MATE_CONNECTOR : A part studio mate connector.
 * @value COMPOSITE : A composite part body, which can contain bodies of any other type
 */
export enum BodyType
{
    SOLID,
    SHEET,
    WIRE,
    POINT,
    MATE_CONNECTOR,
    COMPOSITE
}

/**
 * Specifies the topological type of a given entity. Used in several queries as
 * a filter, or on any query explicitly with [qEntityFilter]
 *
 * Thus, one can obtain all the vertices in a part studio with
 *`qEverything(EntityType.VERTEX)`,
 * and can obtain all the vertices attached to solid bodies with
 * `qBodyType(qEverything(EntityType.VERTEX), BodyType.SOLID)`
 *
 * A query for every part in a part studio is
 * `qBodyType(qEverything(EntityType.BODY), BodyType.SOLID)`
 *
 * @value VERTEX : A zero-dimensional point or vertex
 * @value EDGE : A one-dimensional line, curve, or edge
 * @value FACE : A two-dimensional surface, planar face, or non-planar face
 * @default @value BODY : A solid, surface, wire, or point body
 */
export enum EntityType
{
    VERTEX,
    EDGE,
    FACE,
    BODY
}

/**
 * Specifies the adjacency type of queried entities.
 *
 * @seealso [qAdjacent]
 *
 * @value VERTEX : Entities share at least a vertex
 * @value EDGE : Entities share at least an edge
 */
export enum AdjacencyType
{
    VERTEX,
    EDGE
}

/**
 * Specifies the geometric type of queried entities.
 *
 * @seealso [qGeometry]
 *
 * @value LINE : A straight line or edge
 * @value CIRCLE : A circle of constant radius
 * @value ARC : A segment of a circle
 * @value OTHER_CURVE : Any one-dimensional entity which is not described above
 *      (e.g. splines, ellipses, etc.)
 * @value PLANE : A construction plane or planar face
 * @value CYLINDER : A surface which forms the side of a right circular cylinder
 * @value CONE : A surface which forms the side of a right circular cone
 * @value SPHERE : A surface which forms the boundary of a sphere
 * @value TORUS : A surface which forms the boundary of a torus
 * @value REVOLVED : A surface constructed by revolving a curve around an axis (unless it is simplified to one of the types above)
 * @value EXTRUDED : A surface constructed by extruding or sweeping a curve along a line (unless it is simplified to one of the types above)
 * @value OTHER_SURFACE : Any two-dimensional entity which is not described above (e.g. the side of an arbitrary loft)
 * @value ALL_MESH : A surface or a body that is fully mesh or an edge between two mesh surfaces.
 * @value MIXED_MESH : A body that contains both mesh and non-mesh surfaces or an edge between a mesh and a non-mesh surfaces.
 * @value MESH : A surface that is mesh, a body that contains mesh surfaces or an edge bordering a mesh surface.
 */
export enum GeometryType
{
    LINE,
    CIRCLE,
    ARC,
    OTHER_CURVE,
    PLANE,
    CYLINDER,
    CONE,
    SPHERE,
    TORUS,
    REVOLVED,
    EXTRUDED,
    OTHER_SURFACE,
    ALL_MESH,
    MIXED_MESH,
    MESH
}

/**
 * Specifies which cap queried entities should belong to.
 *
 * @seealso [qCapEntity]
 *
 * @value START : finds entities belonging to the start cap
 * @value END : finds entities belonging to the end cap
 * @value EITHER : finds entities belonging to either cap
 */
export enum CapType
{
    START,
    END,
    EITHER
}

/**
 * Specifies whether the entity was created for construction (e.g. a
 * construction line or construction plane).
 *
 * Can be used in a filter on a query parameter to only allow certain selections:
 * ```
 * annotation { "Name" : "Edges to use", "Filter" : EntityType.EDGE && ConstructionObject.NO }
 * definition.edges is Query;
 * ```
 * @seealso [qConstructionFilter]
 *
 * @value YES : Matches only entities which are created for construction
 * @value NO  : Matches only entities which are not created for construction
 */
export enum ConstructionObject
{
    YES,
    NO
}

/**
 * Specifies whether an entity appears in the sheet metal flat view, or the main view.
 *
 * @seealso [qSheetMetalFlatFilter]
 *
 * @value YES : Matches entities which belong to a flattened sheet metal part.
 * @value NO  : Matches entities which do not belong to a flattened sheet metal part.
 */
export enum SMFlatType
{
    YES,
    NO
}

/**
 * Specifies whether we allow meshes. Default is `NO`.
 *
 * Can be used in a filter on a query parameter to only allow certain selections:
 * ```
 * annotation { "Name" : "Bodies", "Filter" : EntityType.BODY && AllowMeshGeometry.YES }
 * definition.body is Query;
 * ```
 *
 * @value YES : Allow meshes
 * @value NO  : Disallow meshes
 */
export enum AllowMeshGeometry
{
    YES,
    NO
}

/**
 * Specifies whether we allow flat entities. Default is `NO`.
 *
 * Can be used in a filter on a query parameter to only allow certain selections:
 * ```
 * annotation { "Name" : "Bodies", "Filter" : EntityType.BODY && AllowFlattenedGeometry.YES }
 * definition.body is Query;
 * ```
 *
 * @value YES : Allow flat entities
 * @value NO  : Disallow flat entities
 */
export enum AllowFlattenedGeometry
{
    YES,
    NO
}

/**
 * Specifies whether the entities should belong to an active sheet metal model.
 *
 * Can be used in a filter on a query parameter to only allow certain selections:
 * ```
 * annotation { "Name" : "Sheet metal bodies", "Filter" : EntityType.BODY && ActiveSheetMetal.YES }
 * definition.body is Query;
 * ```
 *
 * @value YES : matches only entities which belong to an active sheet metal model
 * @value NO  : matches only entities which do not belong to an active sheet metal model
 */
export enum ActiveSheetMetal
{
    YES,
    NO
}

/**
 * Specifies geometry corresponding to a certain type of topological entity in the sheet metal
 * [master body](/FsDoc/library.html#module-sheetMetalAttribute.fs) for active sheet metal models.
 *
 * Can be used in a filter on a query parameter to only allow certain selections:
 * ```
 * annotation { "Name" : "Sheet metal definition edges", "Filter" : SheetMetalDefinitionEntityType.EDGE }
 * definition.entities is Query;
 * ```
 *
 * @value VERTEX : matches entities defined by a sheet metal master body vertex. This includes vertices, edges, and
 * faces at the corners, bend ends, fillets, and chamfers of sheet metal models.
 * @value EDGE : matches entities defined by a sheet metal master body edge. This includes edges and faces along the
 * sides of sheet metal walls.
 * @value FACE : matches entities defined by a sheet metal master body face. This includes faces of sheet metal walls.
 */
export enum SheetMetalDefinitionEntityType
{
    VERTEX,
    EDGE,
    FACE
}

/**
 * Specifies whether we allow modifiable only entities. It is default to `NO`.
 *
 * Can be used in a filter on a query parameter to only allow certain selections:
 * ```
 * annotation { "Name" : "Bodies", "Filter" : EntityType.BODY && ModifiableEntityOnly.YES }
 * definition.body is Query;
 * ```
 *
 * @seeAlso [qModifiableEntityFilter]
 *
 * @value YES : Only allow modifiable entities
 * @value NO  : Allow both modifiable and unmodifiable entities
 */
export enum ModifiableEntityOnly
{
    YES,
    NO
}

/**
 * Specifies whether we allow edge points. Default is `YES`.
 *
 * Can be used in a filter on a query parameter to only allow certain selections:
 * ```
 * annotation { "Name" : "Corners", "Filter" : EntityType.VERTEX && AllowEdgePoint.NO }
 * definition.body is Query;
 * ```
 *
 * @value YES : Allow edge points
 * @value NO  : Disallow edge points
 */
export enum AllowEdgePoint
{
    YES,
    NO
}

/**
 * Specifies whether the entities are mesh geometries.
 *
 * @seealso [qMeshGeometryFilter]
 *
 * @value YES : Matches only entities (edges, faces, and bodies) which are meshes
 * @value NO  : Matches only entities (edges, faces, and bodies) which are not meshes
 */
export enum MeshGeometry
{
    YES,
    NO
}

/**
 * Specifies whether the entity is a part of a sketch.
 *
 * Can be used in a filter on a query parameter to only allow certain selections:
 * ```
 * annotation { "Name" : "Sketch curves", "Filter" : EntityType.EDGE && SketchObject.YES }
 * definition.curves is Query;
 * ```
 *
 * @seeAlso [qSketchFilter]
 *
 * @value YES : Matches only entities which are part of a sketch
 * @value NO  : Matches only entities which are not part of a sketch
 */
export enum SketchObject
{
    YES,
    NO
}

/**
 * A set of convenience filters, which are expanded during precondition
 * processing. Can be used as a filter on query parameters, just like their
 * corresponding expansions:
 * ```
 * annotation { "Name" : "Axis", "Filter" : QueryFilterCompound.ALLOWS_AXIS }
 * definition.axis is Query;
 * ```
 * @value ALLOWS_AXIS : Equivalent to
 *      `GeometryType.LINE || GeometryType.CIRCLE || GeometryType.ARC || GeometryType.CYLINDER || BodyType.MATE_CONNECTOR`
 *      and can be processed with [evAxis]
 * @value ALLOWS_DIRECTION : Equivalent to
 *      `GeometryType.LINE || GeometryType.CIRCLE || GeometryType.ARC || GeometryType.CYLINDER || GeometryType.PLANE`
 *      and can be processed with [extractDirection]
 * @value ALLOWS_PLANE : Equivalent to
 *      `GeometryType.PLANE || BodyType.MATE_CONNECTOR`
 *      and can be processed with [evPlane]
 * @value ALLOWS_VERTEX : Equivalent to
 *      `EntityType.VERTEX || BodyType.MATE_CONNECTOR`
 *      and can be processed with [evVertexPoint]
 */
export enum QueryFilterCompound
{
    ALLOWS_AXIS,
    ALLOWS_DIRECTION,
    ALLOWS_PLANE,
    ALLOWS_VERTEX
}

/**
 * Specifies a method of comparing two items.
 * @seealso [qFilletFaces]
 */
export enum CompareType
{
    EQUAL,
    LESS,
    LESS_EQUAL,
    GREATER,
    GREATER_EQUAL
}

/**
 * Specifies whether to filter or allow bodies (and their vertices, edges, and faces) consumed by closed composite parts.
 *
 * @seealso [qConsumed]
 *
 * @value YES : Matches only bodies that are consumed
 * @value NO  : Matches only bodies that are not consumed
 */
export enum Consumed
{
    YES,
    NO
}

/**
 * Specifies whether to filter or allow closed or open composite parts.
 *
 * @seealso [qCompositePartTypeFilter]
 *
 * @value OPEN : Matches only open composite parts
 * @value CLOSED  : Matches only closed composite parts
 */
export enum CompositePartType
{
    OPEN,
    CLOSED
}

/**
 * Specifies whether an entity is from an assembly context.
 *
 * Can be used in a filter on a query parameter to only allow certain selections:
 * ```
 * annotation { "Name" : "Edges to use", "Filter" : EntityType.EDGE && InContextObject.NO }
 * definition.edges is Query;
 * ```
 * @value YES : Matches only entities which are from an assembly context
 * @value NO  : Matches only entities which are not from an assembly context
 */
export enum InContextObject
{
    YES,
    NO
}

//Don't strip units off historical queries
/** @internal */
export function stripUnits(value is Query)
{
    if (value.historyType != undefined)
        return value;
    return stripUnits(value as map);
}


// =========================== Special Queries ===============================

/**
 * An empty query, which does not resolve to any entities.
 */
export function qNothing() returns Query
{
    return { queryType : QueryType.NOTHING } as Query;
}

/**
 * A query for all entities of a specified [EntityType] in the context.
 * @seealso [qAllModifiableSolidBodies]
 *
 * @param entityType : @optional @autocomplete `EntityType.BODY`
 */
export function qEverything(entityType is EntityType) returns Query
{
    return { queryType : QueryType.EVERYTHING, "entityType" : entityType } as Query;
}

/**
 * A query for all entities in the context.
 */
export function qEverything() returns Query
{
    return { queryType : QueryType.EVERYTHING } as Query;
}

/**
 * A query for all solid bodies that do not have mesh geometry.
 */
export function qAllNonMeshSolidBodies() returns Query
{
    return qBodyType(qMeshGeometryFilter(qEverything(EntityType.BODY), MeshGeometry.NO), BodyType.SOLID);
}

/**
 * A query for all solid bodies.
 */
export function qAllSolidBodies() returns Query
{
    return qBodyType(qEverything(EntityType.BODY), BodyType.SOLID);
}

/**
 * A query for all solid bodies that do not have mesh geometry or in context geometry, i.e. every non-mesh-containing part
 * displayed in the Part Studio's "Parts" list.
 * @seealso [qAllModifiableSolidBodies]
 */
export function qAllModifiableSolidBodiesNoMesh() returns Query
{
    return qModifiableEntityFilter(qAllNonMeshSolidBodies());
}

/**
 * A query for all modifiable solid bodies, including mesh-containing bodies.
 * @seealso [qAllModifiableSolidBodiesNoMesh]
 */
export function qAllModifiableSolidBodies() returns Query
{
    return qModifiableEntityFilter(qAllSolidBodies());
}

/**
 * A query for one entity in `queryToFilter` at a specified index. The order of entities resolved
 * by a query is deterministic but arbitrary.
 * @param queryToFilter {Query} : A query which resolves to at least n+1 entities
 * @param n {number} : Zero-based index of entity in `queryToFilter`.
 *      @eg `0`  indicates the first entity
 *      @eg `-1` indicates the last entity
 */
export function qNthElement(queryToFilter is Query, n is number) returns Query
precondition
{
    isInteger(n);
}
{
    return { queryType : QueryType.NTH_ELEMENT, "n" : n, "subquery" : queryToFilter } as Query;
}

/**
 * A query for entities in a `queryToFilter` which match a given [EntityType].
 */
export function qEntityFilter(queryToFilter is Query, entityType is EntityType) returns Query
{
    return { queryType : QueryType.ENTITY_FILTER, "entityType" : entityType, "subquery" : queryToFilter } as Query;
}

/**
 * Query for all entities marked with an attribute with name `name`
 * @seealso [setAttribute]
 */
export function qHasAttribute(name is string) returns Query
{
    return { "queryType" : QueryType.ATTRIBUTE_FILTER, "name" : name } as Query;
}

/**
 * Query for all entities in `queryToFilter` marked with an attribute with name `name`
 * @seealso [setAttribute]
 */
export function qHasAttribute(queryToFilter is Query, name is string) returns Query
{
    return { "queryType" : QueryType.ATTRIBUTE_FILTER, "subquery" : queryToFilter, "name" : name } as Query;
}

/**
 * Query for all entities marked with an attribute with name `name` and value exactly equal to `value`
 * @seealso [setAttribute]
 */
export function qHasAttributeWithValue(name is string, value) returns Query
{
    return { "queryType" : QueryType.ATTRIBUTE_FILTER, "name" : name, "valueToMatchExactly" : value } as Query;
}

/**
 * Query for all entities in `queryToFilter` marked with an attribute with name `name` and value exactly equal to `value`
 * @seealso [setAttribute]
 */
export function qHasAttributeWithValue(queryToFilter is Query, name is string, value) returns Query
{
    return { "queryType" : QueryType.ATTRIBUTE_FILTER, "subquery" : queryToFilter, "name" : name, "valueToMatchExactly" : value } as Query;
}

/**
 * Query for all entities marked with an attribute with name `name` and a map value matching
 * every key-value pair in the provided `attributePattern` map.
 * @seealso [setAttribute]
 *
 * @param attributePattern : @eg ```{
 *     "key1" : valueToMatch,
 * }```
 */
export function qHasAttributeWithValueMatching(name is string, attributePattern is map) returns Query
{
    return { "queryType" : QueryType.ATTRIBUTE_FILTER, "name" : name, "attributePattern" : attributePattern } as Query;
}

/**
 * Query for all entities in `queryToFilter` marked with an attribute with name `name` and a map value matching
 * every key-value pair in the provided `attributePattern` map.
 * @seealso [setAttribute]
 *
 * @param attributePattern : @eg ```{
 *     "key1" : valueToMatch,
 * }```
 */
export function qHasAttributeWithValueMatching(queryToFilter is Query, name is string, attributePattern is map) returns Query
{
    return { "queryType" : QueryType.ATTRIBUTE_FILTER, "subquery" : queryToFilter, "name" : name, "attributePattern" : attributePattern } as Query;
}

/**
 * Note: This query is used only for legacy unnamed attributes, which are still supported but no longer reccommended. See the
 * [Attributes](library.html#module-attributes.fs) module for details.
 *
 * A query for entities in a `queryToFilter` which have been assigned a legacy unnamed attribute matching a given `attributePattern`.
 *
 * @param attributePattern : Will only resolve to queries whose legacy unnamed attributes match the type (and possibly the values)
 *      of this pattern.
 *
 *      If attributePattern has a type tag, will only match attributes with that same type tag.
 *      @eg `{} as MyCustomType` will match all attributes with type tag `MyCustomType`
 *
 *      If the attribute has no type tag (i.e. it is a [standard type](variables.html#standard-types) like `string` or `map`),
 *      will match all attributes with that same standard type.
 *      @ex `"asdf"` will match all `string` attributes.
 *      @ex `{}` will match all `map` attributes.
 *
 *      If the attribute is a map, will only match maps which have identical values for every key-value pair in the pattern
 *      @ex `{ "odd" : true }` matches all unnamed `map` attributes that have a field `"odd"` whose value is `true`.
 *      @ex `{ "odd" : true } as MyCustomType` matches all unnamed `map` attributes with the  that have a field `"odd"` whose value is `true`.
 *
 */
export function qAttributeFilter(queryToFilter is Query, attributePattern) returns Query
{
    return { queryType : QueryType.ATTRIBUTE_FILTER, "attributePattern" : attributePattern, "subquery" : queryToFilter } as Query;
}

/**
 * Note: This query is used only for legacy unnamed attributes, which are still supported but no longer reccommended. See the
 * [Attributes](library.html#module-attributes.fs) module for details.
 *
 * A query for all entities which have been assigned a legacy unnamed attribute matching a given `attributePattern`.
 * Equivalent to `qAttributeFilter(qEverything(), attributePattern)`
 */
export function qAttributeQuery(attributePattern) returns Query
{
    return { queryType : QueryType.ATTRIBUTE_FILTER, "attributePattern" : attributePattern} as Query;
}

/**
 * A query for all the entities created by a feature or operation. The feature
 * is given by its feature id, which was passed into the the operation function
 * in order to create the feature.
 *
 * An entity is "created by" an operation if the entity was added to the
 * context as part of that operation. Entities modified, but not created, by an
 * operation are not returned by this query.
 *
 * If an entity is split (as in a split part operation), the resulting entities
 * are "created by" both the original entity's creator and the split part
 * operation.
 *
 * If two entities are merged (as in a union of coincident faces), that entity
 * is "created by" the creators of each merged entity, as well as the merging
 * operation itself.
 *
 * If a sketch's feature id is specified, returns a query for all sketch
 * regions, points, and wire bodies created by the specified sketch.
 *
 * @param featureId : The `Id` of the specified feature. @eg `id + "extrude1"`
 * @param entityType : @optional @autocomplete `EntityType.BODY`
 */
export function qCreatedBy(featureId is Id, entityType is EntityType) returns Query
{
    return { "queryType" : QueryType.CREATED_BY, "featureId" : featureId, "entityType" : entityType } as Query;
}

export function qCreatedBy(featureId is Id) returns Query
{
    return { "queryType" : QueryType.CREATED_BY, "featureId" : featureId } as Query;
}

export function qCreatedBy(features is FeatureList) returns Query
{
    var query = [];
    for (var feature in features)
        query = append(query, qCreatedBy(feature.key));
    return qUnion(query);
}

export function qCreatedBy(features is FeatureList, entityType is EntityType) returns Query
{
    var query = [];
    for (var feature in features)
        query = append(query, qCreatedBy(feature.key, entityType));
    return qUnion(query);
}

/**
 * @internal
 * A transient query, which refers to a single entity in the context. All
 * transient queries are only valid until the context is modified again.
 *
 * This constructor should not be used directly. To obtain a list of transient
 * queries for specific entities, simply pass any other query into
 * [evaluateQuery].
 */
export function qTransient(id is string) returns Query
{
    return { "queryType" : QueryType.TRANSIENT, "transientId" : id } as Query;
}

/**
 * A query for start/end cap vertex, edge, and face entities created by `featureId`.
 * Cap entities are produced by extrude, revolve, sweep, loft and thicken features
 * @param featureId : @autocomplete `id + "extrude1"`
 * @param capType : @autocomplete `CapType.END`
 * @param entityType : @optional @autocomplete `EntityType.FACE`
 */
export function qCapEntity(featureId is Id, capType is CapType, entityType is EntityType) returns Query
precondition
{
    annotation { "Message" : "qCapEntity cannot resolve bodies" }
    entityType != EntityType.BODY;
}
{
    return {
            "queryType" : QueryType.CAP_ENTITY,
            "featureId" : featureId,
            "capType" : capType,
            "entityType" : entityType
        } as Query;
}

/**
 * @param featureId : @autocomplete `id + "extrude1"`
 * @param capType : @autocomplete `CapType.END`
 */
export function qCapEntity(featureId is Id, capType is CapType) returns Query
{
    return {
            "queryType" : QueryType.CAP_ENTITY,
            "featureId" : featureId,
            "capType" : capType
        } as Query;
}

/** @internal */
annotation { "Deprecated" : "[qCapEntity] now takes a [CapType] rather than a `boolean`" }
export function qCapEntity(featureId is Id, isStartCap is boolean) returns Query
{
    return qCapEntity(featureId, isStartCap ? CapType.START : CapType.END);
}

/**
 * A query for vertex, edge, and face entities created by `featureId` that are not cap entities.
 * Cap entities are produced by extrude, revolve, sweep, loft and thicken features
 * @param featureId : @autocomplete `id + "extrude1"`
 * @param entityType: @optional @autocomplete `EntityType.FACE`
 */
export function qNonCapEntity(featureId is Id, entityType is EntityType) returns Query
precondition
{
    annotation { "Message" : "qNonCapEntity cannot resolve bodies" }
    entityType != EntityType.BODY;
}
{
    return qSubtraction(qCreatedBy(featureId, entityType), qCapEntity(featureId, CapType.EITHER));
}

/**
 * @param featureId : @autocomplete `id + "extrude1"`
 */
export function qNonCapEntity(featureId is Id) returns Query
{
    return qSubtraction(qCreatedBy(featureId), qUnion([qCreatedBy(featureId, EntityType.BODY), qCapEntity(featureId, CapType.EITHER)]));
}

/**
 * @internal
 * Under development, not for general use.
 *
 * A query for looking up entities named by opNameEntity
 */
export function qNamed(name is string) returns Query
{
    return makeQuery({"queryType" : "NAMED",
                      "name" : name,
                      "historyType" : "CREATION"});
}

/**
 * A query for the profile edges or vertices created by an [opHole] operation.
 *
 * @param featureId : The [Id] of the specified operation. @eg `id + "hole1"`
 * @param filters {{
 *     @field name {string} : @optional Filter the query for profiles with a given name.
 *         See `name` field of [HoleProfile].
 *     @field identity {Query} : @optional Filter the query for the hole associated with the given identity entity.
 *         See `identities` parameter of [opHole].
 * }}
 */
export function qOpHoleProfile(featureId is Id, filters is map) returns Query
precondition
{
    filters.name is string || filters.name == undefined;
    filters.identity is Query || filters.identity == undefined;
}
{
    return { "queryType" : QueryType.OP_HOLE_PROFILE, "featureId" : featureId, "name" : filters.name, "identity" : filters.identity } as Query;
}

export function qOpHoleProfile(featureId is Id) returns Query
{
    return qOpHoleProfile(featureId, {});
}

/**
 * A query for the hole faces created by an [opHole] operation.
 *
 * @param featureId : The [Id] of the specified operation. @eg `id + "hole1"`
 * @param filters {{
 *     @field name {string} : @optional Filter the query for faces with a given name.
 *         See `faceNames` field of [HoleDefinition].
 *     @field identity {Query} : @optional Filter the query for the hole associated with the given identity entity.
 *         See `identities` parameter of [opHole].
 * }}
 */
export function qOpHoleFace(featureId is Id, filters is map) returns Query
precondition
{
    filters.name is string || filters.name == undefined;
    filters.identity is Query || filters.identity == undefined;
}
{
    return { "queryType" : QueryType.OP_HOLE_FACE, "featureId" : featureId, "name" : filters.name, "identity" : filters.identity } as Query;
}

export function qOpHoleFace(featureId is Id) returns Query
{
    return qOpHoleFace(featureId, {});
}

/**
 * @internal
 * A filter for edges and vertices that exceed a tolerance threshold.
 * @param threshold: @optional Defaults to zero-length tolerance.
 */
export function qToleranceFilter(queryToFilter is Query, threshold is ValueWithUnits) returns Query
precondition
{
    isLength(threshold);
}
{
    return { "queryType" : QueryType.TOLERANCE_FILTER, "subquery" : queryToFilter, "threshold" : stripUnits(threshold) } as Query;
}

export function qToleranceFilter(queryToFilter is Query) returns Query
{
    return qToleranceFilter(queryToFilter, TOLERANCE.zeroLength * meter);
}

/** @internal */
export function transientQueriesToStrings(query is Query)
{
    if (query.queryType == QueryType.TRANSIENT)
        return @transientIdToString(query.transientId);
    else
        return transientQueriesToStrings(query as map);
}

/** @internal */
export function transientQueriesToStrings(value is map) returns map
{
    for (var entry in value)
    {
        if (!(entry.key is array) && !(entry.key is map))
            value[entry.key] = transientQueriesToStrings(entry.value);
        else
        {
            value[entry.key] = undefined;
            value[transientQueriesToStrings(entry.key)] = transientQueriesToStrings(entry.value);
        }
    }
    return value;
}

/** @internal */
export function transientQueriesToStrings(value is array) returns array
{
    for (var i = 0; i < @size(value); i += 1)
    {
        value[i] = transientQueriesToStrings(value[i]);
    }
    return value;
}

/** @internal */
export function transientQueriesToStrings(value)
{
    return value;
}

// =========================== Boolean Queries ================================

/**
 * A query for entities which match any of a list of queries.
 *
 * `qUnion` is guaranteed to preserve order. That is, entities which match
 * queries earlier in the `subqueries` input list will also be listed earlier
 * in the output of `evaluateQuery`.
 *
 * @param subqueries : @autocomplete `[query1, query2]`
 */
export function qUnion(subqueries is array) returns Query
precondition
{
    for (var subquery in subqueries)
        subquery is Query;
}
{
    return { "queryType" : QueryType.UNION, "subqueries" : subqueries } as Query;
}

export function qUnion(query1 is Query, query2 is Query) returns Query
{
  return { "queryType" : QueryType.UNION, "subqueries" : [query1, query2] } as Query;
}

export function qUnion(query1 is Query, query2 is Query, query3 is Query) returns Query
{
  return { "queryType" : QueryType.UNION, "subqueries" : [query1, query2, query3] } as Query;
}

export function qUnion(query1 is Query, query2 is Query, query3 is Query, query4 is Query) returns Query
{
  return { "queryType" : QueryType.UNION, "subqueries" : [query1, query2, query3, query4] } as Query;
}

/**
 * A query for entities which match all of a list of queries.
 * qIntersection preserves the order of the first subquery.
 *
 * @param subqueries : @autocomplete `[query1, query2]`
 */
export function qIntersection(subqueries is array) returns Query
precondition
{
    for (var subquery in subqueries)
        subquery is Query;
}
{
    return { "queryType" : QueryType.INTERSECTION, "subqueries" : subqueries } as Query;
}

export function qIntersection(query1 is Query, query2 is Query) returns Query
{
    return { "queryType" : QueryType.INTERSECTION, "subqueries" : [query1, query2] } as Query;
}

/**
 * A query for entities which match `query1`, but do not match `query2`.
 * qSubtraction preserves the order of `query1`.
 */
export function qSubtraction(query1 is Query, query2 is Query) returns Query
{
    return { "queryType" : QueryType.SUBTRACTION, "query1" : query1, "query2" : query2 } as Query;
}

/**
 * A query for entities which match either `query1` or `query2`, but not both.
 */
export function qSymmetricDifference(query1 is Query, query2 is Query) returns Query
{
    return qUnion([qSubtraction(query1, query2), qSubtraction(query2, query1)]);
}

// ======================= Topological Queries ================================

/**
 * A query for all of the entities (faces, vertices, edges, and bodies) in a
 * context which belong to a specified body or bodies.
 * @param entityType : @optional
 */
export function qOwnedByBody(body is Query, entityType is EntityType) returns Query
{
    return { "queryType" : QueryType.OWNED_BY_PART, "part" : body, "entityType" : entityType } as Query;
}

export function qOwnedByBody(body is Query) returns Query
{
    return { "queryType" : QueryType.OWNED_BY_PART, "part" : body } as Query;
}

/**
 * A query for all of the entities which match a `queryToFilter`, and belong to the
 * specified body or bodies.
 */
export function qOwnedByBody(queryToFilter is Query, body is Query) returns Query
{
    return { "queryType" : QueryType.OWNED_BY_PART, "subquery" : queryToFilter, "part" : body } as Query;
}

/**
 * A query for each body that any of the given `entities` belong to.
 *
 * If a body is passed in, the result will include that body itself.
 */
export function qOwnerBody(entities is Query) returns Query
{
    return { "queryType" : QueryType.OWNER_PART, "query" : entities } as Query;
}

/**
 * A query for each part contained in `compositeParts`.
 */
export function qContainedInCompositeParts(compositeParts is Query) returns Query
{
    return { "queryType" : QueryType.CONTAINED_IN_COMPOSITE, "compositeParts" : compositeParts } as Query;
}

/**
 * A query for each composite part containing `bodies`.
 */
export function qCompositePartsContaining(bodies is Query) returns Query
{
    return { "queryType" : QueryType.COMPOSITE_CONTAINING, "bodies" : bodies } as Query;
}

/**
 * A query for each composite part of the given type containing `bodies`.
 */
export function qCompositePartsContaining(bodies is Query, compositePartType is CompositePartType) returns Query
{
    return { "queryType" : QueryType.COMPOSITE_CONTAINING, "bodies" : bodies, "compositePartType" : compositePartType } as Query;
}

/**
 * A query for non-composite entities in `entities` and constituents of composite parts in `entities`.
 */
export function qFlattenedCompositeParts(entities is Query) returns Query
{
    return qUnion([qSubtraction(entities, qBodyType(entities, BodyType.COMPOSITE)), qContainedInCompositeParts(entities)]);
}

/**
 * A query for all entities in `queryToFilter` which are consumed by any closed composite part, or all
 * entities of `queryToFilter` which are not consumed by any closed composite part.
 */
export function qConsumed(queryToFilter is Query, consumed is Consumed) returns Query
{
    return { "queryType" : QueryType.CONSUMED, "consumed" : consumed, "subquery" : queryToFilter } as Query;
}

/**
 * A query for all bodies in `queryToFilter` which are either open or closed composite parts, depending on the second parameter.
 */
export function qCompositePartTypeFilter(queryToFilter is Query, compositePartType is CompositePartType) returns Query
{
    return { "queryType" : QueryType.COMPOSITE_PART_TYPE_FITLER, "compositePartType" : compositePartType, "subquery" : queryToFilter } as Query;
}

/**
 * A query for each mesh element that any `selectedMeshVertices` belong to.
 * `selectedMeshVertices` should be the point bodies created when a user selects a mesh vertex. Mesh vertices
 * which have not been selected cannot be queried in FeatureScript
 *
 * @param selectedMeshVertices: One or more mesh vertices whose owning elements are queried.
 * @param entityType: The type of resulting entities. Can be EntityType.BODY, EntityType.FACE or EntityType.EDGE.
 *                    @autocomplete `EntityType.BODY`
 */
export function qSourceMesh(selectedMeshVertices is Query, entityType is EntityType) returns Query
precondition
{
    annotation { "Message" : "EntityType.VERTEX is not supported" }
    entityType == EntityType.BODY || entityType == EntityType.FACE || entityType == EntityType.EDGE;
}
{
    return { "queryType" : QueryType.SOURCE_MESH, "query" : selectedMeshVertices, "entityType" : entityType } as Query;
}

annotation { "Deprecated" : "Use `qSourceMesh` with `EntityType.BODY`" }
export function qSourceMesh(selectedMeshVertices is Query) returns Query
{
    return { "queryType" : QueryType.SOURCE_MESH, "query" : selectedMeshVertices, "entityType" : EntityType.BODY } as Query;
}

/**
 * A query for entities that are adjacent to the given `seed` entities.
 *
 * @param seed: One or more entities whose adjacent neighbors are queried. The result does not include the original `seed` entities
 *              (unless they are adjacent to other `seed` entities)
 * @param adjacencyType:
 *        @eg `AdjacencyType.VERTEX` will return entities that share at least a vertex with the `seed` entities.
 *        @eg `AdjacencyType.EDGE` will return entities that share at least an edge with the `seed` entities. For example,
 *                `qAdjacent(whiteSquareOnChessBoard, AdjacencyType.EDGE)` would return all four surrounding black squares,
 *                but not the four diagonal white squares.
 * @param entityType: The type of resulting entities @optional
 */
export function qAdjacent(seed is Query, adjacencyType is AdjacencyType, entityType is EntityType) returns Query
precondition
{
    entityType != EntityType.BODY;
    annotation { "Message" : "Entities cannot have AdjacencyType.EDGE with vertices, use AdjacencyType.VERTEX instead" }
    !(adjacencyType == AdjacencyType.EDGE && entityType == EntityType.VERTEX);
}
{
    return { "queryType" : adjacencyTypeToQueryType[adjacencyType], "query" : seed, "entityType" : entityType } as Query;
}

export function qAdjacent(seed is Query, adjacencyType is AdjacencyType) returns Query
{
    return { "queryType" : adjacencyTypeToQueryType[adjacencyType], "query" : seed } as Query;
}

const adjacencyTypeToQueryType = {
    AdjacencyType.VERTEX : QueryType.VERTEX_ADJACENT,
    AdjacencyType.EDGE : QueryType.EDGE_ADJACENT
};

annotation { "Deprecated" : "Use `qAdjacent` with `AdjacencyType.VERTEX`" }
export function qVertexAdjacent(query is Query, entityType is EntityType) returns Query
precondition
{
    entityType != EntityType.BODY;
}
{
    return { "queryType" : QueryType.VERTEX_ADJACENT, "query" : query, "entityType" : entityType } as Query;
}

annotation { "Deprecated" : "Use `qAdjacent` with `AdjacencyType.EDGE`" }
export function qEdgeAdjacent(query is Query, entityType is EntityType) returns Query
precondition
{
    entityType != EntityType.BODY;
    entityType != EntityType.VERTEX;
}
{
    return { "queryType" : QueryType.EDGE_ADJACENT, "query" : query, "entityType" : entityType } as Query;
}

/**
 * A query for edges in a `queryToFilter` which match a given [EdgeTopology].
 */
export function qEdgeTopologyFilter(queryToFilter is Query, edgeTopologyType is EdgeTopology) returns Query
{
    return { queryType : QueryType.EDGE_TOPOLOGY_FILTER, "edgeTopologyType" : edgeTopologyType, "subquery" : queryToFilter } as Query;
}

/**
 * A query for the start or end vertices of edges.
 */
export function qEdgeVertex(edgeQuery is Query, atStart is boolean)
{
    return { "queryType" : QueryType.EDGE_VERTEX, "query" : edgeQuery, "atStart" : atStart } as Query;
}



//LOOP_AROUND_FACE,
//SHELL_CONTAINING_FACE,
//======================== Geometry Type Queries ==============================

/**
 * A query for all entities in `queryToFilter` with a specified [GeometryType].
 */
export function qGeometry(queryToFilter is Query, geometryType is GeometryType) returns Query
{
    return { "queryType" : QueryType.GEOMETRY, "geometryType" : geometryType, "subquery" : queryToFilter } as Query;
}

/**
 * A query for all entities in `queryToFilter` which are bodies of the a specified [BodyType],
 * or are owned by bodies with the specified [BodyType]
 */
export function qBodyType(queryToFilter is Query, bodyType is BodyType) returns Query
{
    return qBodyType(queryToFilter, [bodyType]);
}

/**
 * A query for all entities in `queryToFilter` with any of a list of [BodyType]s.
 *
 * @param bodyTypes : An array of [BodyType]s.
 */
export function qBodyType(queryToFilter is Query, bodyTypes is array) returns Query
precondition
{
    for (var bodyType in bodyTypes)
    {
        bodyType is BodyType;
    }
}
{
    if (queryToFilter.queryType == QueryType.EVERYTHING)
    {
        queryToFilter.bodyType = bodyTypes;
        return queryToFilter;
    }
    return { "queryType" : QueryType.BODY_TYPE, "bodyType" : bodyTypes, "subquery" : queryToFilter } as Query;
}

/**
 * A query for all construction entities or all non-construction entities in `queryToFilter`.
 * @seealso [ConstructionObject]
 */
export function qConstructionFilter(queryToFilter is Query, constructionFilter is ConstructionObject) returns Query
{
    return { "queryType" : QueryType.CONSTRUCTION_FILTER, "constructionFilter" : constructionFilter, "subquery" : queryToFilter } as Query;
}

/**
 * A query for all entities in `queryToFilter` belonging to an active sheet metal part.
 *
 * @seealso [ActiveSheetMetal]
 */
export function qActiveSheetMetalFilter(queryToFilter is Query, activeSheetMetal is ActiveSheetMetal) returns Query
{
    return { "queryType" : QueryType.ACTIVE_SM_FILTER, "activeSheetMetal" : activeSheetMetal, "subquery" : queryToFilter } as Query;
}

/**
 * A query for all entities in `queryToFilter` belonging to a flattened sheet metal part.
 * @seealso [SMFlatType]
 */
export function qSheetMetalFlatFilter(queryToFilter is Query, filterFlat is SMFlatType) returns Query
{
    return { "queryType" : QueryType.SM_FLAT_FILTER, "flatFilter" : filterFlat, "subquery" : queryToFilter } as Query;
}

annotation { "Deprecated" : "Use [qSheetMetalFlatFilter]" }
export function qSMFlatFilter(subquery is Query, filterFlat is SMFlatType) returns Query
{
    return qSheetMetalFlatFilter(subquery, filterFlat);
}

/**
 * A query for parts to which `sheetMetalEntities` are attached (e.g. sheet metal bend line entities are attached to a
 * flattened sheet metal part)
 */
export function qPartsAttachedTo(sheetMetalEntities is Query) returns Query
{
    return { "queryType" : QueryType.PARTS_ATTACHED_TO, "subquery" : sheetMetalEntities } as Query;
}

/**
 * A query for entities in sheet metal flattened body corresponding to any `entitiesInFolded` which
 * are part of 3D sheet metal bodies
 */
export function qCorrespondingInFlat(entitiesInFolded is Query) returns Query
{
    return { queryType : QueryType.CORRESPONDING_IN_FLAT, "subquery" : entitiesInFolded } as Query;
}

/**
 * A query for all mesh entities or all non-mesh entities in `queryToFilter`.
 *
 * A body is considered a "mesh entity" if any of its faces or edges have mesh geometry.
 * @seealso [MeshGeometry]
 */
export function qMeshGeometryFilter(queryToFilter is Query, meshGeometryFilter is MeshGeometry) returns Query
{
    return { "queryType" : QueryType.MESH_GEOMETRY_FILTER, "meshGeometryFilter" : meshGeometryFilter, "subquery" : queryToFilter } as Query;
}

/**
 * A query for all modifiable entities, or all non-modifiable entities in `queryToFilter`.
 *
 * An entity is considered non-modifiable if it is an in-context entity.
 * @seealso [ModifiableEntityOnly]
 * @seealso [qAllModifiableSolidBodies]
 */
export function qModifiableEntityFilter(queryToFilter is Query) returns Query
{
    return { "queryType" : QueryType.MODIFIABLE_ENTITY_FILTER, "subquery" : queryToFilter } as Query;
}

/**
 * A query for all sketch entities, or all non-sketch entities in `queryToFilter`.
 */
export function qSketchFilter(queryToFilter is Query, sketchObjectFilter is SketchObject) returns Query
{
    return { "queryType" : QueryType.SKETCH_OBJECT_FILTER, "sketchObjectFilter" : sketchObjectFilter, "subquery" : queryToFilter } as Query;
}


// ======================= Geometry matching Queries ==========================
/**
 * A query for all planar face entities that are parallel to the `referencePlane`.
 * @param referencePlane : The plane to reference when checking for parallelism.
 * @param allowAntiparallel : Whether to also return entities that are antiparallel.
 */
export function qParallelPlanes(queryToFilter is Query, referencePlane is Plane, allowAntiparallel is boolean) returns Query
{
    var normal is Vector = referencePlane.normal;
    return { "queryType" : QueryType.PLANE_NORMAL, "subquery" : queryToFilter, "normal" : normal, "allowAntiparallel" : allowAntiparallel } as Query;
}

/**
 * A query for all planar face entities in `queryToFilter` that are parallel to the `referencePlane`.
 * @param referencePlane : The plane to reference when checking for parallelism.
 */
export function qParallelPlanes(queryToFilter is Query, referencePlane is Plane) returns Query
{
    var normal is Vector = referencePlane.normal;
    return { "queryType" : QueryType.PLANE_NORMAL, "subquery" : queryToFilter, "normal" : normal, "allowAntiparallel" : true } as Query;
}

/**
 * A query for all planar face entities in `queryToFilter` that are parallel to a plane specified by the `normal` vector.
 * @param normal : The normal vector to reference when checking for parallelism.
 * @param allowAntiparallel : Whether to also return entities that are antiparallel.
 */
export function qParallelPlanes(queryToFilter is Query, normal is Vector, allowAntiparallel is boolean) returns Query
precondition
{
    @size(normal) == 3;
}
{
    return { "queryType" : QueryType.PLANE_NORMAL, "subquery" : queryToFilter, "normal" : normalize(normal), "allowAntiparallel" : allowAntiparallel } as Query;
}

/**
 * A query for all planar faces in `queryToFilter` that are parallel to the given direction vector
 * (i.e., the plane normal is perpendicular to `direction`).
 */
export function qPlanesParallelToDirection(queryToFilter is Query, direction is Vector) returns Query
precondition
{
    @size(direction) == 3;
}
{
    return { "queryType" : QueryType.PLANE_PARALLEL_DIRECTION, "subquery" : queryToFilter, "direction" : normalize(direction) } as Query;
}

/**
 * A query for all faces in `queryToFilter` that are parallel to the given direction vector
 * e.g.
 *    if it is a planar face, the plane normal is perpendicular to `direction`
 *    if it is a cylindrical face, the axis is parallel to `direction`
 *    if it is an extruded face, the extrude direction is parallel to `direction`
 */
export function qFacesParallelToDirection(queryToFilter is Query, direction is Vector) returns Query
precondition
{
    @size(direction) == 3;
}
{
    return { "queryType" : QueryType.FACE_PARALLEL_DIRECTION, "subquery" : queryToFilter, "direction" : normalize(direction) } as Query;
}

/**
 * A query for all planar face entities in `queryToFilter` that are parallel to a plane specified by the `normal` vector.
 * @param normal : The normal vector to reference when checking for parallelism.
 */
export function qParallelPlanes(queryToFilter is Query, normal is Vector) returns Query
precondition
{
    @size(normal) == 3;
}
{
    return { "queryType" : QueryType.PLANE_NORMAL, "subquery" : queryToFilter, "normal" : normalize(normal), "allowAntiparallel" : true } as Query;
}

// ======================= Tangency Queries ===================================
//TANGENT_EDGES,
//TANGENT_FACES,

// ======================= Faces Related Queries ==============================
/**
 * A query for a set of faces connected to `seed` via convex edges, flood-filling
 * across any number of convex edges.
 *
 * A convex edge is an edge which forms a convex angle along the full length of
 * the edge. A convex angle is strictly less than 180 degrees for flat faces,
 * or faces with negative curvature. If one face has positive curvature, and
 * the other has flat or positive curvature, a convex angle is less than or
 * equal to 180 degrees. Thus, the two bounding edges of an exterior fillet are
 * considered convex.
 */
export function qConvexConnectedFaces(seed is Query) returns Query
{
    return { "queryType" : QueryType.CONVEX_CONNECTED_FACES, "subquery" : seed } as Query;
}

/**
 * A query for a set of faces connected to `seed` via concave edges, flood-filling
 * across any number of concave edges.
 *
 * A concave edge is an edge which forms a concave angle along the full length of
 * the edge. A concave angle is strictly greater than 180 degrees for flat faces,
 * or faces with positive curvature. If one face has negative curvature, and
 * the other has flat or negative curvature, a concave angle is less than or
 * equal to 180 degrees. Thus, the two bounding edges of an interior fillet are
 * considered concave.
 */
export function qConcaveConnectedFaces(seed is Query) returns Query
{
    return { "queryType" : QueryType.CONCAVE_CONNECTED_FACES, "subquery" : seed } as Query;
}

/**
 * A query for a set of faces connected to `seed` via tangent edges, flood-filling
 * across any number of tangent edges.
 *
 * A tangent edge is an edge joining two faces such that the surface direction
 * is continuous across the edge, at every point along the full length of the
 * edge.
 */
export function qTangentConnectedFaces(seed is Query) returns Query
{
    return { "queryType" : QueryType.TANGENT_CONNECTED_FACES, "subquery" : seed } as Query;
}

/**
 * A query for a set of faces connected to `seed` via tangent edges, flood-filling
 * across any number of tangent edges.
 *
 * A tangent edge is an edge joining two faces such that the surface direction
 * is continuous across the edge, up to the given `angleTolerance`, at every
 * point along the full length of the edge.
 */
export function qTangentConnectedFaces(seed is Query, angleTolerance is ValueWithUnits) returns Query
precondition
{
    isAngle(angleTolerance);
}
{
    return { "queryType" : QueryType.TANGENT_CONNECTED_FACES, "subquery" : seed, "angleTolerance" : stripUnits(angleTolerance) } as Query;
}

/**
 * A query for a chain of tangent edges connected to `seed` via tangent vertices, chaining
 * across any number of tangent vertices.
 */
export function qTangentConnectedEdges(seed is Query) returns Query
{
    return { "queryType" : QueryType.TANGENT_CONNECTED_EDGES, "subquery" : seed } as Query;
}

/**
 * A query for a set of edges defining a loop. If the `seed` has laminar edges, this query will extend
 * to include all laminar loops that contain any `seed` edges. If the `seed` has faces, the result will
 * include the loops forming the outer boundary of the joined faces.
 */
export function qLoopEdges(seed is Query) returns Query
{
    return { "queryType" : QueryType.LOOP_EDGES, "subquery" : seed } as Query;
}

/**
 * @internal
 * Unconventional semantics, not for general use.
 *
 * A query for linear edges parallel to any edge in `referenceEdges`.
 * Only edges from the owner bodies of `referenceEdges` are included.
 */
export function qParallelEdges(referenceEdges is Query) returns Query
{
    return { "queryType" : QueryType.PARALLEL_EDGES, "subquery" : referenceEdges } as Query;
}

/**
 * A query for all linear edges in `queryToFilter` which are parallel (or anti-parallel) to the given `direction`.
 */
export function qParallelEdges(queryToFilter is Query, direction is Vector) returns Query
precondition
{
    @size(direction) == 3;
}
{
    return { "queryType" : QueryType.PARALLEL_EDGES, "queryToFilter" : queryToFilter, "direction" : normalize(direction) } as Query;
}

/**
 * A query to find all linear edges in `queryToFilter` which are parallel (or anti-parallel) to any linear edge in `edges`.
 */
export function qParallelEdges(queryToFilter is Query, edges is Query) returns Query
{
    return { "queryType" : QueryType.PARALLEL_EDGES, "queryToFilter" : queryToFilter, "edges" : edges } as Query;
}

/**
 * Given a face and an edge, query for all faces bounded by the given face, on
 * the side of the given edge.
 *
 * For example, to select an entire pocket, pass in the face which surrounds
 * the pocket, and an edge of the face which touches that pocket.
 *
 * @param faceAndEdge : Should match a face and an edge. If multiple faces and
 *          edges match, used the first face and the first edge.
 *          @autocomplete `qUnion([boundaryFace, adjacentEdge])`
 */
export function qLoopBoundedFaces(faceAndEdge is Query) returns Query
{
    return { "queryType" : QueryType.LOOP_BOUNDED_FACES, "subquery" : faceAndEdge } as Query;
}

/**
 * Given a seed face and bounding entities, matches all adjacent faces inside
 * the bounding entities, expanding from the seed face.
 *
 * @param faceAndBoundingEntities : A Query for the seed face, followed by any boundary faces
 *          or edges. The seed face must be first, so a `qUnion` should be used
 *          to guarantee the order.
 *          @autocomplete `qUnion([seedFace, boundingEntities])`
 */
export function qFaceOrEdgeBoundedFaces(faceAndBoundingEntities is Query) returns Query
{
    return { "queryType" : QueryType.FACE_OR_EDGE_BOUNDED_FACES, "subquery" : faceAndBoundingEntities } as Query;
}

/**
 * Given a single face inside a hole or hole-like geometry, returns all faces of that hole.
 *
 * @param seed : A query for a single face inside the hole.
 */
export function qHoleFaces(seed is Query) returns Query
{
    return { "queryType" : QueryType.HOLE_FACES, "subquery" : seed } as Query;
}

/**
 * A query for all fully enclosed, 2D regions created by a sketch.
 *
 * @param featureId : The feature id of the [Sketch] being queried. @autocomplete `id + "sketch1"`
 * @param filterInnerLoops : Specifies whether to exclude sketch regions fully
 *      contained in other sketch regions.  A region whose border has a vertex
 *      or edge on the outside boundary is not considered "contained."
 *      Default is false.
 *      @optional
 */
export function qSketchRegion(featureId is Id, filterInnerLoops is boolean) returns Query
{
    return { "queryType" : QueryType.SKETCH_REGION, "featureId" : featureId, "filterInnerLoops" : filterInnerLoops } as Query;
}

/**
 * @param featureId : @autocomplete `id + "sketch1"`
 */
export function qSketchRegion(featureId is Id) returns Query
{
    return { "queryType" : QueryType.SKETCH_REGION, "featureId" : featureId, "filterInnerLoops" : false } as Query;
}

/**
 * A query that filters out duplicate vertices.
 * When duplicates are found, the vertex with the lowest deterministic ID is used.
 */
export function qUniqueVertices(vertices is Query) returns Query
{
    return { "queryType" : QueryType.UNIQUE_VERTICES, "subquery" : vertices } as Query;
}

/**
 * @internal
 * This is designed as a stable way of associating an edge with its
 * orientation, and it used in generated code.
 *
 * However, since it cannot be evaluated like normal queries,
 * it's marked internal to avoid confusion.
 *
 * @param faceQuery
 * @param edgeQuery
 */
export function qCoEdge(faceQuery is Query, edgeQuery is Query) returns Query
{
    return { "queryType" : QueryType.COEDGE, "faceQuery" : faceQuery, "edgeQuery" : edgeQuery } as Query;
}

/**
 * A query for all mate connectors owned by `parts`.
 */
export function qMateConnectorsOfParts(parts is Query) returns Query
{
    return { "queryType" : QueryType.MATE_CONNECTOR, "subquery" : parts } as Query;
}
// TODO: qOwnerPartsOfMateConnectors(mateConnectors is Query)

/**
 * A query for fillet faces of radius equal to, less than or equal to, or greater than or equal to the
 * input faces. If `facesToCompareTo` does not match one or more fillet faces, the resulting query will not
 * match any faces. Will find the fillet radius from each face and compare to find faces of all fillets
 * on that body that satisfy the compareType.
 *
 * If `facesToCompareTo` resolves to multiple fillet faces, all are matched independently. That is,
 * `qFilletFaces(qUnion([q1, q2], compareType))` returns the same thing as
 * `qUnion([qFilletFaces(q1, compareType), qFilletFaces(q2, compareType)])`.
 */
export function qFilletFaces(facesToCompareTo is Query, compareType is CompareType) returns Query
precondition
{
    compareType == CompareType.EQUAL || compareType == CompareType.LESS_EQUAL || compareType == CompareType.GREATER_EQUAL;
}
{
    return { "queryType" : QueryType.FILLET_FACES, "compareType" : compareType, "subquery" : facesToCompareTo } as Query;
}

/**
 * Matches any faces or edges within owner bodies of entities in `referenceEntities` which are geometrically identical
 * (same size and shape) to the face or edge in `referenceEntities`.
 *
 * If `referenceEntities` resolves to multiple entities, all are matched independently. That is,
 * `qMatching(qUnion([q1, q2]))` returns the same thing as
 * `qUnion([qMatching(q1), qMatching(q2)])`.
 */
export function qMatching(referenceEntities is Query) returns Query
{
    return { "queryType" : QueryType.PATTERN, "subquery" : referenceEntities } as Query;
}

/** @internal */
annotation { "Deprecated" : "Use `qMatching`" }
export function qMatchingFaces(subquery is Query) returns Query
{
    return qMatching(subquery);
}

/**
 * A query for entities created by a specific instance or instances of an `opPattern` operation.
 *
 * @param featureId : The `Id` of the specified feature. @eg `id + "pattern1"`
 * @param instanceNames : The names of the instances to query for, a subset of the instanceNames passed into the `opPattern` operation.
 * @param entityType : @autocomplete `EntityType.BODY`
 */
export function qPatternInstances(featureId is Id, instanceNames is array, entityType is EntityType) returns Query
{
    return { "queryType" : QueryType.PATTERN_INSTANCES, "featureId" : featureId, "instanceNames" : instanceNames, "entityType" : entityType } as Query;
}

export function qPatternInstances(featureId is Id, instanceName is string, entityType is EntityType) returns Query
{
    return { "queryType" : QueryType.PATTERN_INSTANCES, "featureId" : featureId, "instanceNames" : [instanceName], "entityType" : entityType } as Query;
}

/**
 * A query for the true dependency of the given `dependentEntities`. For instance, the true dependency of the extruded
 * body will be the face or sketch edges of the profile from which it is extruded.
 */
export function qDependency(dependentEntities is Query) returns Query
{
    return { "queryType" : QueryType.DEPENDENCY, "subquery" : dependentEntities } as Query;
}

/**
 * A query for the true dependency of the given `dependentEntities`, specifically for use with wire edges that
 * have been created from laminar edges. If the immediate dependency is not laminar then it will
 * track back until it reaches a laminar dependency (if there is one).
 */
export function qLaminarDependency(dependentEntities is Query) returns Query
{
    return { "queryType" : QueryType.LAMINAR_DEPENDENCY, "subquery" : dependentEntities } as Query;
}

//===================================== Containment / Intersection Queries =====================================
/**
 * A query for all entities (bodies, faces, edges, or points)  in `queryToFilter` containing a specified point.
 * @param point : A 3D point, in world space.
 */
export function qContainsPoint(queryToFilter is Query, point is Vector) returns Query
precondition
{
    is3dLengthVector(point);
}
{
    return { "queryType" : QueryType.CONTAINS_POINT, "subquery" : queryToFilter, "point" : stripUnits(point) } as Query;
}

/**
 * A query for all entities (bodies, faces, edges, or points) in `queryToFilter` touching a specified infinite line.
 */
export function qIntersectsLine(queryToFilter is Query, line is Line) returns Query
{
    return { "queryType" : QueryType.INTERSECTS_LINE, "subquery" : queryToFilter, "line" : stripUnits(line) } as Query;
}

/**
 * A query for all entities (bodies, faces, edges, or points) in `queryToFilter` touching a specified infinite plane.
 * @param plane :
 *          @eg `plane(vector(0, 0, 0) * meter, vector(0, 0, 1))`
 */
export function qIntersectsPlane(queryToFilter is Query, plane is Plane) returns Query
{
    return { "queryType" : QueryType.INTERSECTS_PLANE, "subquery" : queryToFilter, "plane" : stripUnits(plane) } as Query;
}

/**
 * A query for all entities (bodies, faces, edges, or points)  in `queryToFilter` coinciding with a specified infinite plane.
 * @param plane :
 *          @eg `plane(vector(0, 0, 0) * meter, vector(0, 0, 1))`
 */
// TODO: tolerance
export function qCoincidesWithPlane(queryToFilter is Query, plane is Plane) returns Query
{
    return { "queryType" : QueryType.COINCIDES_WITH_PLANE, "subquery" : queryToFilter, "plane" : stripUnits(plane) } as Query;
}

/**
 * A query for all entities (bodies, faces, edges or points) in `queryToFilter` that are within a specified radius from a point.
 * @param point : The point from which to check distance from.
 * @param radius : The distance away from the point.
 */
export function qWithinRadius(queryToFilter is Query, point is Vector, radius is ValueWithUnits) returns Query
precondition
{
    is3dLengthVector(point);
}
{
    return { "queryType" : QueryType.INTERSECTS_BALL, "subquery" : queryToFilter, "point" : stripUnits(point), "radius" : stripUnits(radius) } as Query;
}

//===================================== Optimization Queries =====================================
/**
 *  A query for the entity in `queryToFilter` closest to a point.
 *
 *  In the case of a tie, resolves to all entities within `TOLERANCE.zeroLength` of being the closest.
 *  @param point : A position vector for the point to find entities closest to.
 */
export function qClosestTo(queryToFilter is Query, point is Vector) returns Query
precondition
{
    is3dLengthVector(point);
}
{
    return { "queryType" : QueryType.CLOSEST_TO, "subquery" : queryToFilter, "point" : stripUnits(point)} as Query;
}

/**
 *  A query for the entity in `queryToFilter` farthest along a `direction` in world space.
 *  In the case of a tie, resolves to all entities within `TOLERANCE.zeroLength` of being the farthest.
 *  @param direction : A vector for the direction to find the entity farthest away.
 */
export function qFarthestAlong(queryToFilter is Query, direction is Vector) returns Query
precondition
{
    @size(direction) == 3;
}
{
    return { "queryType" : QueryType.FARTHEST_ALONG, "subquery" : queryToFilter, "direction" : normalize(direction) } as Query;
}

/**
 * A query to find the largest entity (by length, area, or volume)  in `queryToFilter`.
 *
 * If `queryToFilter` contains entities of different dimensionality (e.g. both solid bodies and faces), only entities of
 * the highest dimension are considered. Entities are compared by length, area or volume. Multiple entities may be
 * returned if they tie within tolerance.
 */
export function qLargest(queryToFilter is Query) returns Query
{
    return { "queryType" : QueryType.LARGEST, "subquery" : queryToFilter } as Query;
}

/**
 * A query to find the smallest entity (by length, area, or volume) in `queryToFilter`.
 *
 * If `queryToFilter` contains entities of different dimensionality (e.g. solid bodies and faces), only entities of
 * the highest dimension are considered. Entities are compared by length, area or volume. Multiple entities may be
 * returned if they tie within tolerance.
 */
export function qSmallest(queryToFilter is Query) returns Query
{
    return { "queryType" : QueryType.SMALLEST, "subquery" : queryToFilter } as Query;
}

// ==================================== Historical Query stuff ================================

/** @internal */
export function makeQuery(value is map) returns Query
{
    return value as Query;
}

/** @internal */
export function makeQuery(operationId is Id, queryType is string, entityType, value is map) returns Query
precondition
{
    entityType == undefined || entityType is EntityType;
}
{
    return mergeMaps(value,
                     { "operationId" : operationId, "queryType" : queryType,
                       "entityType" : entityType, "historyType" : "CREATION" }) as Query;
}

/** @internal */
export function dummyQuery(operationId is Id, entityType is EntityType, disambiguationOrder is number) returns Query
{
    return makeQuery({ "operationId" : operationId,
                       historyType : "CREATION",
                       "entityType" : entityType,
                       queryType : "DUMMY",
                       disambiguationData : [{ disambiguationType : "ORDER", order : disambiguationOrder }] });
}

export function dummyQuery(operationId is Id, entityType is EntityType) returns Query
{
    return makeQuery({ "operationId" : operationId, historyType : "CREATION",
                "entityType" : entityType, queryType : "DUMMY" });
}

/**
 * Given the id of a split feature, get entities of a given `EntityType` on
 * the front or the back side of the split.
 * For a split by face or part, the front denotes the body in the direction
 * of the split tool's surface normal, and the back denotes the body opposite
 * the normal.
 * For a split by isocline, the front denotes non-steep faces and edges,
 * and the back denotes steep entities.
 * @param featureId : @eg `id + "split1"`
 * @param backBody {boolean} :
 *          @eg `false` indicates the entities in the front.
 *          @eg `true` indicates the entities in the back.
 */
export function qSplitBy(featureId is Id, entityType, backBody is boolean) returns Query
precondition
{
    entityType == undefined || entityType is EntityType;
}
{
    return makeQuery(featureId, "SPLIT", entityType, { "isFromBackBody" : backBody });
}

/**
 * Gets the wire body entities created for a specific sketch entity. If the
 * sketch id created multiple sketch entities, will return all the wire
 * bodies.
 *
 * @param operationId : Id of the sketch feature. @autocomplete `id + "sketch1"`
 * @param entityType :
 *          @ex `EntityType.EDGE` to match the edges on the wire bodies.
 *          @eg `EntityType.BODY` to match the bodies themselves.
 *          @ex `undefined` to match both.
 * @param sketchEntityId : Sketch id.
 */
export function sketchEntityQuery(operationId is Id, entityType, sketchEntityId is string) returns Query
precondition
{
    entityType == undefined || entityType is EntityType;
}
{
    return makeQuery(operationId, "SKETCH_ENTITY", entityType,
            { "sketchEntityId" : sketchEntityId });
}

/** @internal */
export function orderDisambiguation(order is number)
{
    return { disambiguationType : "ORDER", "order" : order };
}

/** @internal */
export function topologyDisambiguation(topology is array)
{
    return { disambiguationType : "TOPOLOGY", entities : topology };
}

/** @internal */
export function topologyDisambiguationEdgeConnected(topology is array)
{
    return { disambiguationType : "TOPOLOGY", entities : topology,  edgeConnectivityOnly : true};
}

/** @internal */
export function originalSetDisambiguation(queries is array)
{
    return { disambiguationType : "ORIGINAL_DEPENDENCY", originals : queries };
}

/** @internal */
export function trueDependencyDisambiguation(queries is array)
{
    return { disambiguationType : "TRUE_DEPENDENCY", derivedFrom : queries };
}

/** @internal */
export function externalDependencyDisambiguation(queries is array)
{
    return { disambiguationType : "EXTERNAL_DEPENDENCY", derivedFrom : queries };
}

/** @internal */
export function ownerDisambiguation(topology is array)
{
    return { disambiguationType : "OWNER", owners : topology };
}

//====================== Query evaluation ========================

/**
 * Returns an array of queries for the individual entities in a context which match
 * a specified query.  The returned array contains exactly one transient query
 * for each matching entity at the time of the call.  If the context is modified,
 * the returned queries may become invalid and no longer match an entity.
 *
 * It is usually not necessary to evaluate queries, since operation and
 * evaluation functions can accept non-evaluated queries. Rather, the evaluated
 * queries can be used to count the number of entities (if any) that match a
 * query, or to iterate through the list to process entities individually.
 *
 * The order of entities returned by this function is arbitrary (and generally
 * not predictable) except in the case of a `qUnion` query. In that case, the
 * entities matched by earlier queries in the argument to `qUnion` are
 * returned first.
 */
export function evaluateQuery(context is Context, query is Query) returns array
{
    var result = @evaluateQuery(context, { "query" : query });
    var out = [];
    for (var transientId in result)
    {
        // Inline the construction of the query rather than calling qTransient because the function call would represent
        // a nontrivial performance cost when evaluateQuery is used in a loop, or other performance-sensitive context.
        out = append(out, { "queryType" : QueryType.TRANSIENT, "transientId" : transientId } as Query);
    }
    return out;
}

/**
 * Returns `true` if the supplied queries evaluate to the same set of entities. This function is order-invariant, so if
 * the two queries evaluate to the same entities, but in a different order, the function will still return `true`.
 */
export function areQueriesEquivalent(context is Context, first is Query, second is Query) returns boolean
{
    return isQueryEmpty(context, qSubtraction(first, second)) && isQueryEmpty(context, qSubtraction(second, first));
}

/**
 * Returns `true` if `query` evaluates to nothing. Equivalent to `evaluateQuery(context, query) == []` or
 * `size(evaluateQuery(context, query)) == 0`, but faster than either of those approaches if the query is not empty.
 */
export function isQueryEmpty(context is Context, query is Query) returns boolean
{
    // Use @evaluateQuery builtin to avoid overhead of packing transient ids into transient queries
    return @evaluateQuery(context, { "query" : query }) == [];
}

//==================

/**
 * @internal
 * @param paramName
 */
export function notFoundErrorKey(paramName is string) returns string
{
    return paramName ~ "notFoundError";
}


/** @internal */
export function qCompressed(version is number, query is string, root is Id) returns Query
precondition
{
    isInteger(version);
}
{
    return @unpackQuery(version, query, root);
}

/** @internal */
export function qCoincidentFilter(subquery is Query, target is Query) returns Query
{
    return { "queryType" : QueryType.COINCIDENT, "subquery" : subquery, "target" : target } as Query;
}

//backward compatibility -- do not use these functions.  Will need to figure out a way to remove them.

/** @internal */
annotation { "Deprecated" : "Use `makeQuery`" }
export function query(operationId is Id, queryType is string, entityType, value is map) returns Query
precondition
{
    entityType == undefined || entityType is EntityType;
}
{
    return makeQuery(operationId, queryType, entityType, value);
}

/** @internal */
annotation { "Deprecated" : "Use `makeQuery`" }
export function query(value is map) returns Query
{
    return makeQuery(value);
}

